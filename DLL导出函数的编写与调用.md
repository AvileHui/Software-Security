# DLL与动态链接 #
　　  
## 实验说明 ##
**实验题目：**  
　
　　编写DLL，导出指定的函数，并在exe中调用导出函数。
　　                                  
　　详细了解动态链接的机制。
　　

###**DLL的制造者** 

###一、从DLL中导出：

####.DLL文件：

                                  
　　1、导出函数(export function)：导出函数可以被其它模块调用。
　　                                  
　　2、内部函数(internal function)：内部函数在定义它们的DLL程序内部使用。
                                  
有两种从 DLL 导出函数的方法：
                                  
　　在生成 DLL 时，创建一个模块定义 (.def) 文件并使用该 .def 文件。（如果希望按序号而不是按名称从 DLL 导出函数，则请使用此方法。）
　　                                  
　　在函数的定义中使用 __declspec(dllexport) 关键字。
　　　　                       
　　　　                                                                        
**用上述任何方法导出函数时，确保使用 __stdcall 调用约定。**

（1）.def文件：
                                  
　　模块定义 (.def) 文件是包含一个或多个描述 DLL 各种特性的 Module 语句的文本文件。
　　                                  
.def 文件必须至少包含下列模块定义语句：
　　                                  
　　1）文件中的第一个语句必须是 LIBRARY 语句。此语句将 .def 文件标识为属于 DLL。LIBRARY 语句的后面是DLL的名称。链接器将此名称放到 DLL 的导入库中。
　　                                  
　　2）EXPORTS 语句列出名称，可能的话还会列出DLL导出函数的序号值。通过在函数名的后面加上@符和一个数字，给函数分配序号值。当指定序号值时，序号值的范围必须是从1到N，其中N是DLL导出函数的个数。如果希望按序号导出函数，请参见按序号而不是按名称从 DLL 导出函数以及本主题。
                                
                                                                   
例如，包含实现二进制搜索树的代码的 DLL 看上去可能像下面这样：

        enter code hereIBRARY   BTREE
        EXPORTS
        Insert   @1
        Delete   @2
        Member   @3
        Min   @4


（2）__declspec(dllexport) 关键字：
                                  
　　__declspec(dllexport) 关键字从DLL导出数据、函数、类或类成员函数。__declspec(dllexport)会将导出指令添加到对象文件中，因此您不需要使用 .def 文件。
　　                                  
若要导出函数，__declspec(dllexport) 关键字必须出现在调用约定关键字的左边（如果指定了关键字）。
　　            
　　                                                                   
　　例如：

      __declspec(dllexport) void __cdecl Function1(void);
　　                                  
　　                                                                   
**注意：__declspec(dllexport) 不能应用于具有 __clrcall 调用约定的函数。**

　　  

###二、入口函数：
                                  
　　每一个 DLL 必须有一个入口点，DLLMain是一个缺省的入口函数。DLLMain负责初始化和结束工作，每当一个新的进程或者该进程的新的线程访问DLL时，或者访问DLL的每一个进程或者线程不再使用DLL或者结束时，都会调用DLLMain。但是，使用TerminateProcess或TerminateThread 结束进程或者线程，不会调用 DLLMain。 

DLLMain的函数原型： 

    BOOL APIENTRY DLLMain(HANDLE hModule,DWORD ul_reason_for_call,LPVOID 
    lpReserved)
    {
    	switch(ul_reason_for_call) 
    	{
    	case DLL_PROCESS_ATTACH:
    	.......
    	case DLL_THREAD_ATTACH:
    	.......
    	case DLL_THREAD_DETACH:
    	.......
    	case DLL_PROCESS_DETACH:
    	.......
    	return TRUE;
    	}
    }
                                     
参数： 
                                 
　　hMoudle：是动态库被调用时所传递来的一个指向自己的句柄(实际上，它是指向_DGROUP段的一个选择 符)；
　　                                 
　　ul_reason_for_call：是一个说明动态库被调原因的标志。当进程或线程装入或卸载动态连接库的时候，操作系统调用入口函数，并说明动态连接库被调用的原因。
　　                                 
　　它所有的可能值为： 
　　                                 
　　DLL_PROCESS_ATTACH: 进程被调用； 
　　                                 
　　DLL_THREAD_ATTACH: 线程被调用； 
　　                                 
　　DLL_PROCESS_DETACH: 进程被停止； 
　　                                 
　　DLL_THREAD_DETACH: 线程被停止； 
　　                                 
　　lpReserved：是一个被系统所保留的参数； 
　　                                 

###三、调用方式 
                                 
　　1、静态调用方式：由编译系统完成对DLL的加载和应用程序结束时DLL卸载的编码（如还有其它程序使用该DLL，则Windows对DLL的应用记录减1，直到所有相关程序都结束对该 DLL 的使用时才释放它，简单实用，但不够灵活，只能满足一般要求。 
　　                                 
　　隐式的调用： 
　　                                 
　　为隐式调用DLL，可执行文件必须从 DLL 的提供程序获取下列各项：
　　                                 
　　a.包含导出函数和/或 C++ 类的声明的头文件（.h文件）。类、函数和数据均应具有__declspec(dllimport)。
　　                                 
　　b.要链接的导入库（.LIB files）。（生成 DLL 时链接器创建导入库。）
　　                                 
　　c.实际的 DLL（.dll 文件）。
　　                                
　　                                 
**说明：**
                                 
　　需要把产生动态连接库时产生的 .LIB 文件加入到应用程序的工程中，想使用 DLL 中的函数时，只须说明一下。隐式调用不需要调用 LoadLibrary() 和 FreeLibrary()。程序员在建立一个 DLL 文件时，链接程序会自动生成一个与之对应的 LIB 导入文件。该文件包含了每一个 DLL 导出函数的符号名和可选的标识号，但是并不含有实际的代码。LIB 文件作为 DLL 的替代文件被编译到应用程序项目中。
　　                                 
　　当程序员通过静态链接方式编译生成应用程序时，应用程序中的调用函数与 LIB 文件中导出符号相匹配，这些符号或标识号进入到生成的 EXE 文件中。LIB 文件中也包含了对应的 DL L文件名（但不是完全的路径名），链接程序将其存储在 EXE 文件内部。 
　　                                 
　　当应用程序运行过程中需要加载DLL文件时，Windows根据这些信息发现并加载DLL，然后通过符号名或标识号实现对DLL函数的动态链接。所有被应用程序调用的 DLL 文件都会在应用程序EXE 文件加载时被加载在到内存中。可执行程序链接到一个包含DLL输出函数信息的输入库文件(.LIB文件)。操作系统在加载使用可执行程序时加载 DLL。可执行程序直接通过函数名调用 DLL 的输出函数，调用方法和程序内部其 它的函数是一样的。 
　　                                 
　　                                 
　　2、动态调用方式：是由编程者用API函数加载和卸载DLL来达到调用DLL的目的，使用上较复杂，但能更加有效地使用内存，是编制大型应用程序时的重要方式。
　　                                 
　　显式的调用：
　　                                 
　　在显式调用下，应用程序必须进行函数调用以在运行时显式加载 DLL。为显式链接到 DLL，应用程序必须：
　　                                 
　　a.调用 LoadLibrary（或相似的函数）以加载 DLL 和获取模块句柄。
　　                                 
　　b.调用 GetProcAddress，以获取指向应用程序要调用的每个导出函数的函数指针。由于应用程序是通过指针调用 DLL 的函数，编译器不生成外部引用，故无需与导入库链接。
　　                                 
　　c.使用完 DLL 后调用 FreeLibrary。
　　                                
　                                 
**说明：**
                                 
　　是指在应用程序中用 LoadLibrary或MFC提供的AfxLoadLibrary显式的将自己所做的动态连接库调进来，动态连接库的文件名即是上面两个函数的参数，再用 GetProcAddress()获取想要引入的函数。
　　                                 
　　自此，你就可以象使用如同本应用程序自定义的函数一样来调用此引入函数了。在应用程序退出之前，应该用 FreeLibrary 或 MFC 提供的 AfxFreeLibrary 释放动态连接库。直接调用Win32的LoadLibary函数，并指定DLL的路径作为参数。LoadLibary返回HINSTANCE参数，应用程序在调用GetProcAddress函数时使用这一参数。GetProcAddress函数将符号名或标识号转换为DLL内部的地址。程序员可以决定DLL文件何时加载或不加载，显式链接在运行时决定加载哪个DLL文件。使用DLL的程序在使用之前必须加载（LoadLibrary）加载DLL从而得到一个DLL模块的句柄，然后调用GetProcAddress函数得到输出函数的指针，在退出之前必须卸载DLL(FreeLibrary)。 


###四、关于调用约定
                                 
　　动态库输出函数的约定有两种：调用约定和名字修饰约定。
                                 
　　1)调用约定(Calling convention)：决定函数参数传送时入栈和出栈的顺序，由调用者还是被调用者把参数弹出栈，以及编译器用来识别函数名字的修饰约定。
                                 
　　函数调用约定有多种，这里简单说一下：
                                 
　　1、__stdcall 调用约定相当于16位动态库中经常使用的PASCAL调用约定。在32位的VC++5.0中PASCAL调用约定不再被支持（实际上它已被定义为__stdcall。除了__pascal 外，__fortran和__syscall也不被支持），取而代之的是__stdcall调用约定。两者实质上是一致的，即函数的参数自右向左通过栈传递，被调用的函数在返回前清理传送参数的内存栈，但不同的是函数名的修饰部分（关于函数名的修饰部分在后面将详细说明）。
                                 
　　_stdcall 是 Pascal 程序的缺省调用方式，通常用于Win32API中，函数采用从右到左的压栈方式，自己在退出时清空堆栈。VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上 "@" 和参数的字节数。
                                 
　　2、C 调用约定（即用__cdecl 关键字说明）按从右至左的顺序压参数入栈，由调用者把参数弹出栈。对于传送参数的内存栈是由调用者维护的（正因为如此，实现可变参数的函数只能使用该调用约定）。另外，在函数名修饰约定方面也有所不同。_cdecl 是 C 和 C++ 程序缺省的调用方式。每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用 _stdcall 函数的大。函数采用从右到左的压栈方式。VC 将函数编译后会在函数名前面加上下划线前缀。 它是 MFC 缺省调用约定。
                                 
　　3、__fastcall 调用约定是 "人" 如其名，它的主要特点就是快，因为它是通过寄存器来传送参数的（实际上，它用 ECX 和 EDX 传送前两个双字（DWORD）或更小的参数，剩下的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的内存栈），在函数名修饰约定方面，它和前两者均不同。
                                 
　　_fastcall方式的函数采用寄存器传递参数，VC 将函数编译后会在函数名前面加上"@"前缀，在函数名后加上"@"和参数的字节数。
                                 
　　4、thiscall 仅仅应用于 "C++" 成员函数。this 指针存放于 CX 寄存器，参数从右到左压。thiscall 不是关键词，因此不能被程序员指定。
                                 
　　5、naked call采用 1-4 的调用约定时，如果必要的话，进入函数时编译器会产生代码来保存ESI，EDI，EBX，EBP寄存器，退出函数时则产生代码恢复这些寄存器的内容。
                                 
　　naked call不产生这样的代码。naked call不是类型修饰符，故必须和_declspec 共同使用。
                                 
　　关键字 __stdcall、__cdecl 和 __fastcall 可以直接加在要输出的函数前，也可以在编译环境的 Setting...\C/C++ \Code Generation 项选择。当加在输出函数前的关键字与编译环境中的选择不同时，直接加在输出函数前的关键字有效。它们对应的命令行参数分别为/Gz、/Gd 和 /Gr。缺省状态为/Gd，即__cdecl。
                                 
　　要完全模仿 PASCAL 调用约定首先必须使用 __stdcall 调用约定，至于函数名修饰约定，可以通过其它方法模仿。还有一个值得一提的是 WINAPI 宏，Windows.h 支持该宏，它可以将出函数翻译成适当的调用约定，在 WIN32 中，它被定义为 __stdcall。使用 WINAPI 宏可以创建自己的 APIs。

                                 
###五、DLL程序和调用其输出函数的程序的关系 
                                 
　　1、DLL与进程、线程之间的关系 
　　                                 
　　DLL模块被映射到调用它的进程的虚拟地址空间。 
　　                                 
　　DLL使用的内存从调用进程的虚拟地址空间分配，只能被该进程的线程所访问。 
　　                                 
　　DLL的句柄可以被调用进程使用；调用进程的句柄可以被DLL使用。 
　　                                 
　　DLL使用调用进程的栈。 
　　                                 
　　2、关于共享数据段 
　　                                 
　　DLL定义的全局变量可以被调用进程访问；DLL可以访问调用进程的全局数据。使用同一DLL的每一个进程都有自己的DLL全局变量实例。如果多个线程并 发访问同一变量，则需要使用同步机制；对一个DLL的变量，如果希望每个使用DLL的线程都有自己的值，则应该使用线程局部存储(TLS，Thread Local Strorage)。 


###六、存在的安全隐患：
                                 
规则 DLL 中有内存泄漏，但代码看起来很正常。
                                 
　　引起内存泄漏的一个可能原因是 MFC 创建了在消息处理函数内使用的临时对象。在规则 DLL 中，MFC 不自动释放分配给这些对象的内存。
　　                                 
　　                                                                  
　　                                                                                                   
-------------------------------------------------------------------------------------------------------------------

>  **参考链接：**
>

> 链接：https://msdn.microsoft.com/zh-cn/library/d1587c1h.aspx
>
> 来源：Microsoft MSDN
>
> 链接：http://www.360doc.com/content/05/0919/14/494_13312.shtml
>
> 来源：360DOC
>
